# Описание кодов статусов
- `200` - успех
- `401` - нет авторизации - `not_access`
- `403` - неверные данные - `invalid_data`
- `500` - критическая ошибка сервера - `critical`

# Формат ответа:
- `data` - данные
- `error` - объект ошибки, если есть

# Объект ошибки
- `message` - описание ошибки
- `stack` - стэк вызовов

<!-- ## Request
## Controller
## Model
## Response
## Testing -->
# Регистрация

## Request
`/api/signup` - `login, email (не обязательный), password` нового пользователя

## Controller
- проверка на валидность полученных данных
- проверка на существование данного пользователя
- генерация success и refresh токена
- отправка данных на фронт

## Model
- `hasUser` - проверка наличия пользователя
- `saveUser` - сохранение пользователя в таблице User

## Response
- user - `id`
- tokens - `access_token, refresh_token, expire`

## Testing
- При успехе получаем 200, id пользователя и токены
- С cуществующим login получаем 403, и сообщение об ошибке

# Авторизация
## Request
`/api/signin` = `login, password`

## Controller
- проверка на валидность полученных данных
- получение юзера или ошибка если его не существует
- сверка паролей
- генерация success и refresh токена
- отправка данных на фронт

## Model
- `getUser` - получение пользователя

## Response
- user - `id`
- tokens - `access_token, refresh_token, expire`

## Testing
- При успехе получаем 200, id и токены пользователя
- При несуществующем login получаем 403, и сообщение об ошибке
- При неверном пароле получаем 403, и сообщение об ошибке
- С некорректными данными получаем 403, и сообщение об ошибке

# Токенизация
## Request
`/api/refresh` - `Bearer ${resfresh_token}` - запрос на получение новый пары токенов
`TokenController.check` - работает как middleware перед обработкой защищенного маршрута

## Controller
- check:
  - Получение токена из заголовка
  - Верификация токена
  - Запись id usera в `res.locals.userId`
- refresh:
  - Получение токена из заголовка
  - Верификация токена
  - Получение юзера из БД
  - Сравение токенов из бд и заголовка
  - Создание новой пары токенов
  - Отправка данных на фронт

## Model
- `save` - сохранение новой или обновление созданной записи в БД (`userId`, `refresh`);
- `get` - получение записи с id пользователя и его refresh токеном

## Response
- user - `id, access_token, refresh_token, expire`

## Testing
- При заходе на защищеный маршрут с верным access токеном получаем 200
- При заходе на защищеный маршрут с просроченым access токеном получаем 403 и объект ошибки
- При заходе на защищеный маршрут с отсутствующим токеном получаем 403 и объект ошибки
- При заходе на защищеный маршрут с неверным токеном получаем 403 и объект ошибки
- При рефреше с верным рефреш токеном получаем 200 и набор новых токенов
- При рефреше с отсутствующим рефреш токеном получаем 403 и объект ошибки
- При рефреше с неверным рефреш токеном получаем 403 и объект ошибки

# Разлогирование
## Request
`/api/signout` - `Bearer ${resfresh_token}`

## Controller
- Получение токена из заголовка
- Получение id пользователя из токена
- Удаление записи из БД токенов
- Отправка `success:true` на фронт

## Model
- `delete` - удаление записи с id пользователя и его refresh токеном

## Response
- success - `true`

## Testing
- При успешном разлогировании получаем 200, и success: true
- При разлогировании с отсутствующем токеном токеном получаем 403 и объект ошибки
- При разлогировании с неверным токеном получаем 401 и объект ошибки

# Cловари
## Request
`/api/dictionary/create` - `name` - создание словаря
`/api/dictionary/getall` - получения всех словарей

## Controller
- сreate
  - Проверка существует ли словарь с таким именем у пользователя или нет
  - Если нет, то сохраняем

- getAll
  - Возвращает все словари пользователя

## Model
`has` - проверка существует ли данный свловарь
`save` - создает новый словарь
`getAll` - получение всех словарей

## Relations
- c таблицей `words`

## Response
- сreate
  - success - `true`
- getall
  - dictionaries - `id, userId, name, words`

## Testing
- При создании нового словаря при успехе получаем 200, success true
- При создании нового словаря без имени получаем 403 и объект ошибки
- При создании нового словаря с cуществующим именем получаем 403 и сообщение об ошибке
- При получении всех словарей получаем 200 и массив dictionaries c массивом words

# Cлова - Words
## Request
`/api/words/create` - `ru`, `en`, `dictionary_id` - создание слова
`/api/words/changeCount` - `words_id, lang` - изменение счетчика для слова

## Controller
- сreate
  - Сохранение слова
- changeCount
  - Обновление счетчика слова

## Model
`save` - создание слова
`update` - увеличение на 1 счетчика слова

## Response
- сreate
  - success - `true`
- changeCount
  - success - `true`

## Testing
- При cохранении нового cлова при успехе получаем 200, success true
- При cохранении нового cлова без поля ru получаем 403 и объект ошибки
- При cохранении нового cлова без поля en получаем 403 и объект ошибки
- При cохранении нового cлова без поля dictionary_id получаем 403 и объект ошибки
- При измении счетчика слова при успехе получаем 200, success true
- После изменения счетчика слова он действительно изменен

# Домащний экран
`/screen/home/create`

## Controller
- Получение словарей из БД
- Нормализация словарей и слов

## Model
Используется DictionaryModel

## Response
- dictionaries - `id, name, words`

## Testing
- При получении данных получаем 200, и массив dictionaries